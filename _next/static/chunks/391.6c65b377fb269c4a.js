(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[391],{5671:function(e,n,t){"use strict";t.d(n,{T:function(){return f}});var r=t(5893),i=t(9008),a=t.n(i),o=t(1163),s=t(7294),u=t(9147),c=t.n(u),d=t(3454);t(7319);let l=e=>{let n=(0,s.useRef)(null),i=(0,s.useMemo)(()=>e.sources.map(e=>{let{name:n,contents:i}=e;return{name:n,...function(e){let n;let i=null;{i=document.createElement("div");let a=t(4631);n=a(i,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(t){return(0,r.jsx)("div",{...t,children:(0,r.jsx)("div",{ref(t){i&&t&&(t.appendChild(i),n.setOption("value",e))}})})}}}(i)}}),e.sources),u=(0,s.useRef)(null),l=(0,s.useMemo)(()=>{if(e.gui){let n=t(4376);return new n.GUI({autoPlace:!1})}},[]),f=(0,o.useRouter)(),p=f.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[m,g]=(0,s.useState)(null),[h,b]=(0,s.useState)(null);return(0,s.useEffect)(()=>{p?b(p[1]):b(i[0].name),l&&u.current&&u.current.appendChild(l.domElement);let t={active:!0},r=()=>{t.active=!1};try{let a=n.current,o=e.init({canvas:a,pageState:t,gui:l});o instanceof Promise&&o.catch(e=>{console.error(e),g(e)})}catch(s){console.error(s),g(s)}return r},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(a(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("h1",{children:e.name}),(0,r.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat(d.env.REPOSITORY_NAME,"/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,r.jsx)("p",{children:e.description}),m?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("p",{children:"Is WebGPU Enabled?"}),(0,r.jsx)("p",{children:"".concat(m)})]}):null]}),(0,r.jsxs)("div",{className:c().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:u}),(0,r.jsx)("canvas",{ref:n})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("nav",{className:c().sourceFileNav,children:(0,r.jsx)("ul",{children:i.map((e,n)=>(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"#".concat(e.name),"data-active":h==e.name,onClick(){b(e.name)},children:e.name})},n))})}),i.map((e,n)=>(0,r.jsx)(e.Container,{className:c().sourceFileContainer,"data-active":h==e.name},n))]})]})},f=e=>(0,r.jsx)(l,{...e})},7391:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return d}});var r=t(5671),i="@binding(0) @group(0) var<storage, read> size: vec2<u32>;\n@binding(1) @group(0) var<storage, read> current: array<u32>;\n@binding(2) @group(0) var<storage, read_write> next: array<u32>;\n\noverride blockSize = 8;\n\nfn getIndex(x: u32, y: u32) -> u32 {\n  let h = size.y;\n  let w = size.x;\n\n  return (y % h) * w + (x % w);\n}\n\nfn getCell(x: u32, y: u32) -> u32 {\n  return current[getIndex(x, y)];\n}\n\nfn countNeighbors(x: u32, y: u32) -> u32 {\n  return getCell(x - 1, y - 1) + getCell(x, y - 1) + getCell(x + 1, y - 1) + \n         getCell(x - 1, y) +                         getCell(x + 1, y) + \n         getCell(x - 1, y + 1) + getCell(x, y + 1) + getCell(x + 1, y + 1);\n}\n\n@compute @workgroup_size(blockSize, blockSize)\nfn main(@builtin(global_invocation_id) grid: vec3<u32>) {\n  let x = grid.x;\n  let y = grid.y;\n  let n = countNeighbors(x, y);\n  next[getIndex(x, y)] = select(u32(n == 3u), u32(n == 2u || n == 3u), getCell(x, y) == 1u); \n} \n",a="struct Out {\n  @builtin(position) pos: vec4<f32>,\n  @location(0) cell: f32,\n}\n\n@binding(0) @group(0) var<uniform> size: vec2<u32>;\n\n@vertex\nfn main(@builtin(instance_index) i: u32, @location(0) cell: u32, @location(1) pos: vec2<u32>) -> Out {\n  let w = size.x;\n  let h = size.y;\n  let x = (f32(i % w + pos.x) / f32(w) - 0.5) * 2. * f32(w) / f32(max(w, h));\n  let y = (f32((i - (i % w)) / w + pos.y) / f32(h) - 0.5) * 2. * f32(h) / f32(max(w, h));\n\n  return Out(vec4<f32>(x, y, 0., 1.), f32(cell));\n}\n",o="@fragment\nfn main(@location(0) cell: f32) -> @location(0) vec4<f32> {\n  return vec4<f32>(cell, cell, cell, 1.);\n}\n",s="src/sample/gameOfLife/main.ts";let u=async e=>{let n,t,{canvas:r,pageState:s,gui:u}=e,c=await navigator.gpu.requestAdapter(),d=await c.requestDevice();if(!s.active)return;let l=r.getContext("webgpu"),f=window.devicePixelRatio||1;r.width=r.clientWidth*f,r.height=r.clientHeight*f;let p=navigator.gpu.getPreferredCanvasFormat();l.configure({device:d,format:p,alphaMode:"premultiplied"});let m={width:128,height:128,timestep:4,workgroupSize:8},g=d.createShaderModule({code:i}),h=d.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),b=new Uint32Array([0,0,0,1,1,0,1,1]),y=d.createBuffer({size:b.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Uint32Array(y.getMappedRange()).set(b),y.unmap();let G={arrayStride:2*b.BYTES_PER_ELEMENT,stepMode:"vertex",attributes:[{shaderLocation:1,offset:0,format:"uint32x2"}]},v=d.createShaderModule({code:a}),E=d.createShaderModule({code:o}),S=d.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),P={arrayStride:Uint32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"uint32"}]},w=0,x=0,U,C;function B(){let e=d.createComputePipeline({layout:d.createPipelineLayout({bindGroupLayouts:[h]}),compute:{module:g,entryPoint:"main",constants:{blockSize:m.workgroupSize}}}),r=d.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Uint32Array(r.getMappedRange()).set([m.width,m.height]),r.unmap();let i=m.width*m.height,a=new Uint32Array(i);for(let o=0;o<i;o++)a[o]=.25>Math.random()?1:0;U=d.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Uint32Array(U.getMappedRange()).set(a),U.unmap(),C=d.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});let s=d.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:U}},{binding:2,resource:{buffer:C}}]}),u=d.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:U}}]}),c=d.createRenderPipeline({layout:d.createPipelineLayout({bindGroupLayouts:[S]}),primitive:{topology:"triangle-strip"},vertex:{module:v,entryPoint:"main",buffers:[P,G]},fragment:{module:E,entryPoint:"main",targets:[{format:p}]}}),f=d.createBindGroup({layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:0,size:2*Uint32Array.BYTES_PER_ELEMENT}}]});x=0,t=()=>{let t=l.getCurrentTexture().createView();n=d.createCommandEncoder();let r=n.beginComputePass();r.setPipeline(e),r.setBindGroup(0,x?u:s),r.dispatchWorkgroups(m.width/m.workgroupSize,m.height/m.workgroupSize),r.end();let a=n.beginRenderPass({colorAttachments:[{view:t,loadOp:"clear",storeOp:"store"}]});a.setPipeline(c),a.setVertexBuffer(0,x?C:U),a.setVertexBuffer(1,y),a.setBindGroup(0,f),a.draw(4,i),a.end(),d.queue.submit([n.finish()])}}u.add(m,"timestep",1,60,1),u.add(m,"width",16,1024,16).onFinishChange(B),u.add(m,"height",16,1024,16).onFinishChange(B),u.add(m,"workgroupSize",[4,8,16]).onFinishChange(B),B(),function e(){m.timestep&&++w>=m.timestep&&(t(),w-=m.timestep,x=1-x),requestAnimationFrame(e)}()},c=()=>(0,r.T)({name:"Conway's Game of Life",description:"This example shows how to make Conway's game of life. First, use compute shader to calculate how cells grow or die. Then use render pipeline to draw cells by using instance mesh.",gui:!0,init:u,sources:[{name:s.substring(22),contents:"import { makeSample, SampleInit } from '../../components/SampleLayout';\nimport computeWGSL from './compute.wgsl';\nimport vertWGSL from './vert.wgsl';\nimport fragWGSL from './frag.wgsl';\n\nconst init: SampleInit = async ({ canvas, pageState, gui }) => {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  if (!pageState.active) return;\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: 'premultiplied',\n  });\n\n  const GameOptions = {\n    width: 128,\n    height: 128,\n    timestep: 4,\n    workgroupSize: 8,\n  };\n\n  const computeShader = device.createShaderModule({ code: computeWGSL });\n  const bindGroupLayoutCompute = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'read-only-storage',\n        },\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'read-only-storage',\n        },\n      },\n      {\n        binding: 2,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'storage',\n        },\n      },\n    ],\n  });\n\n  const squareVertices = new Uint32Array([0, 0, 0, 1, 1, 0, 1, 1]);\n  const squareBuffer = device.createBuffer({\n    size: squareVertices.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Uint32Array(squareBuffer.getMappedRange()).set(squareVertices);\n  squareBuffer.unmap();\n\n  const squareStride: GPUVertexBufferLayout = {\n    arrayStride: 2 * squareVertices.BYTES_PER_ELEMENT,\n    stepMode: 'vertex',\n    attributes: [\n      {\n        shaderLocation: 1,\n        offset: 0,\n        format: 'uint32x2',\n      },\n    ],\n  };\n\n  const vertexShader = device.createShaderModule({ code: vertWGSL });\n  const fragmentShader = device.createShaderModule({ code: fragWGSL });\n  let commandEncoder: GPUCommandEncoder;\n\n  const bindGroupLayoutRender = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.VERTEX,\n        buffer: {\n          type: 'uniform',\n        },\n      },\n    ],\n  });\n\n  const cellsStride: GPUVertexBufferLayout = {\n    arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n    stepMode: 'instance',\n    attributes: [\n      {\n        shaderLocation: 0,\n        offset: 0,\n        format: 'uint32',\n      },\n    ],\n  };\n\n  function addGUI() {\n    gui.add(GameOptions, 'timestep', 1, 60, 1);\n    gui.add(GameOptions, 'width', 16, 1024, 16).onFinishChange(resetGameData);\n    gui.add(GameOptions, 'height', 16, 1024, 16).onFinishChange(resetGameData);\n    gui\n      .add(GameOptions, 'workgroupSize', [4, 8, 16])\n      .onFinishChange(resetGameData);\n  }\n\n  let wholeTime = 0,\n    loopTimes = 0,\n    buffer0: GPUBuffer,\n    buffer1: GPUBuffer;\n  let render: () => void;\n  function resetGameData() {\n    // compute pipeline\n    const computePipeline = device.createComputePipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayoutCompute],\n      }),\n      compute: {\n        module: computeShader,\n        entryPoint: 'main',\n        constants: {\n          blockSize: GameOptions.workgroupSize,\n        },\n      },\n    });\n    const sizeBuffer = device.createBuffer({\n      size: 2 * Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Uint32Array(sizeBuffer.getMappedRange()).set([\n      GameOptions.width,\n      GameOptions.height,\n    ]);\n    sizeBuffer.unmap();\n    const length = GameOptions.width * GameOptions.height;\n    const cells = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      cells[i] = Math.random() < 0.25 ? 1 : 0;\n    }\n\n    buffer0 = device.createBuffer({\n      size: cells.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Uint32Array(buffer0.getMappedRange()).set(cells);\n    buffer0.unmap();\n\n    buffer1 = device.createBuffer({\n      size: cells.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,\n    });\n\n    const bindGroup0 = device.createBindGroup({\n      layout: bindGroupLayoutCompute,\n      entries: [\n        { binding: 0, resource: { buffer: sizeBuffer } },\n        { binding: 1, resource: { buffer: buffer0 } },\n        { binding: 2, resource: { buffer: buffer1 } },\n      ],\n    });\n\n    const bindGroup1 = device.createBindGroup({\n      layout: bindGroupLayoutCompute,\n      entries: [\n        { binding: 0, resource: { buffer: sizeBuffer } },\n        { binding: 1, resource: { buffer: buffer1 } },\n        { binding: 2, resource: { buffer: buffer0 } },\n      ],\n    });\n\n    const renderPipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayoutRender],\n      }),\n      primitive: {\n        topology: 'triangle-strip',\n      },\n      vertex: {\n        module: vertexShader,\n        entryPoint: 'main',\n        buffers: [cellsStride, squareStride],\n      },\n      fragment: {\n        module: fragmentShader,\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n    });\n\n    const uniformBindGroup = device.createBindGroup({\n      layout: renderPipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: sizeBuffer,\n            offset: 0,\n            size: 2 * Uint32Array.BYTES_PER_ELEMENT,\n          },\n        },\n      ],\n    });\n\n    loopTimes = 0;\n    render = () => {\n      const view = context.getCurrentTexture().createView();\n      const renderPass: GPURenderPassDescriptor = {\n        colorAttachments: [\n          {\n            view,\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      };\n      commandEncoder = device.createCommandEncoder();\n\n      // compute\n      const passEncoderCompute = commandEncoder.beginComputePass();\n      passEncoderCompute.setPipeline(computePipeline);\n      passEncoderCompute.setBindGroup(0, loopTimes ? bindGroup1 : bindGroup0);\n      passEncoderCompute.dispatchWorkgroups(\n        GameOptions.width / GameOptions.workgroupSize,\n        GameOptions.height / GameOptions.workgroupSize\n      );\n      passEncoderCompute.end();\n      // render\n      const passEncoderRender = commandEncoder.beginRenderPass(renderPass);\n      passEncoderRender.setPipeline(renderPipeline);\n      passEncoderRender.setVertexBuffer(0, loopTimes ? buffer1 : buffer0);\n      passEncoderRender.setVertexBuffer(1, squareBuffer);\n      passEncoderRender.setBindGroup(0, uniformBindGroup);\n      passEncoderRender.draw(4, length);\n      passEncoderRender.end();\n\n      device.queue.submit([commandEncoder.finish()]);\n    };\n  }\n\n  addGUI();\n  resetGameData();\n\n  (function loop() {\n    if (GameOptions.timestep) {\n      wholeTime++;\n      if (wholeTime >= GameOptions.timestep) {\n        render();\n        wholeTime -= GameOptions.timestep;\n        loopTimes = 1 - loopTimes;\n      }\n    }\n\n    requestAnimationFrame(loop);\n  })();\n};\n\nconst GameOfLife: () => JSX.Element = () =>\n  makeSample({\n    name: \"Conway's Game of Life\",\n    description:\n      \"This example shows how to make Conway's game of life. First, use compute shader to calculate how cells grow or die. Then use render pipeline to draw cells by using instance mesh.\",\n    gui: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: './gameOfLife.compute.wgsl',\n        contents: computeWGSL,\n        editable: true,\n      },\n      {\n        name: './gameOfLife.vert.wgsl',\n        contents: vertWGSL,\n        editable: true,\n      },\n      {\n        name: './gameOfLife.frag.wgsl',\n        contents: fragWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default GameOfLife;\n"},{name:"./gameOfLife.compute.wgsl",contents:i,editable:!0},{name:"./gameOfLife.vert.wgsl",contents:a,editable:!0},{name:"./gameOfLife.frag.wgsl",contents:o,editable:!0}],filename:s});var d=c},9147:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__zRR_l",sourceFileNav:"SampleLayout_sourceFileNav__ml48P",sourceFileContainer:"SampleLayout_sourceFileContainer__3s84x"}}}]);