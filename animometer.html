<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=600">
  <title>WebGPU Animometer demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
  <script src="dist/utils.js"></script>
  <style>
    canvas {
      position: absolute;
      left: 0;
      top: 0;
    }
  </style>
</head>

<body>
  <div id="not-supported" style="display: none">WebGPU not supported! Please visit <a href="//webgpu.io">webgpu.io</a> to see the current implementation status.</div>
  <canvas height=600 width=600></canvas>
  <div style="color: white; background: black; position: absolute; top: 10px; left: 10px"><pre id="display"></pre></div>>
  <script>
    if (!navigator.gpu) {
      document.getElementById('not-supported').style.display = 'block';
      alert('WebGPU not supported! Please visit webgpu.io to see the current implementation status.');
    }

    const params = new URLSearchParams(window.location.search);
    const settings = {
      numTriangles: Number(params.get('numTriangles')) || 20000,
      reuseCommandBuffers: Boolean(params.get('reuseCommandBuffers')),
      dynamicOffsets: Boolean(params.get('dynamicOffsets')),
    };

    const vertexShaderGLSL = `#version 450

      layout(std140, set = 0, binding = 0) uniform Time {
          float time;
      };
      layout(std140, set = 1, binding = 0) uniform Uniforms {
          float scale;
          float offsetX;
          float offsetY;
          float scalar;
          float scalarOffset;
      };

      layout(location = 0) in vec4 position;
      layout(location = 1) in vec4 color;

      layout(location = 0) out vec4 v_color;

      void main() {
          float fade = mod(scalarOffset + time * scalar / 10.0, 1.0);
          if (fade < 0.5) {
              fade = fade * 2.0;
          } else {
              fade = (1.0 - fade) * 2.0;
          }
          float xpos = position.x * scale;
          float ypos = position.y * scale;
          float angle = 3.14159 * 2.0 * fade;
          float xrot = xpos * cos(angle) - ypos * sin(angle);
          float yrot = xpos * sin(angle) + ypos * cos(angle);
          xpos = xrot + offsetX;
          ypos = yrot + offsetY;
          v_color = vec4(fade, 1.0 - fade, 0.0, 1.0) + color;
          gl_Position = vec4(xpos, ypos, 0.0, 1.0);
      }
    `;

    const fragmentShaderGLSL = `#version 450

      layout(location = 0) in vec4 v_color;
      layout(location = 0) out vec4 outColor;

      void main() {
          outColor = v_color;
      }
    `;

    async function init() {
      /* Context, Device, SwapChain */
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      await Utils.ready;

      const canvas = document.querySelector('canvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const context = canvas.getContext('gpupresent');

      const swapChainFormat = "bgra8unorm";
      const swapChain = context.configureSwapChain({
        device,
        format: swapChainFormat,
        usage: GPUTextureUsage.TRANSFER_DST | GPUTextureUsage.OUTPUT_ATTACHMENT
      });

      const timeBindGroupLayout = device.createBindGroupLayout({
        bindings: [
          { binding: 0, visibility: GPUShaderStageBit.VERTEX, type: "uniform-buffer" },
        ],
      });

      const bindGroupLayout = device.createBindGroupLayout({
        bindings: [
          { binding: 0, visibility: GPUShaderStageBit.VERTEX, type: "uniform-buffer" },
        ],
      });

      const dynamicBindGroupLayout = device.createBindGroupLayout({
        bindings: [
          { binding: 0, visibility: GPUShaderStageBit.VERTEX, type: "dynamic-uniform-buffer" },
        ],
      });

      const vec4Size = 4 * Float32Array.BYTES_PER_ELEMENT;

      const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [timeBindGroupLayout, bindGroupLayout] });
      const dynamicPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [timeBindGroupLayout, dynamicBindGroupLayout] });

      const pipelineDesc = {
        vertexStage: {
          module: device.createShaderModule({
            code: Utils.compile("v", vertexShaderGLSL),
          }),
          entryPoint: "main",
        },
        fragmentStage: {
          module: device.createShaderModule({
            code: Utils.compile("f", fragmentShaderGLSL),
          }),
          entryPoint: "main"
        },

        primitiveTopology: "triangle-list",

        vertexInput: {
          indexFormat: "uint32",
          vertexBuffers: [{
            // vertex buffer
            stride: 2 * vec4Size,
            stepMode: "vertex",
            attributes: [{
              // vertex positions
              shaderLocation: 0,
              offset: 0,
              format: "float4"
            }, {
              // vertex colors
              shaderLocation: 1,
              offset: vec4Size,
              format: "float4"
            }],
          }],
        },

        rasterizationState: {
          frontFace: 'ccw',
          cullMode: 'none',
        },

        colorStates: [{
          format: swapChainFormat,
          alphaBlend: {},
          colorBlend: {},
        }],
      };

      const pipeline = device.createRenderPipeline(Object.assign({
        layout: pipelineLayout
      }, pipelineDesc));

      const dynamicPipeline = device.createRenderPipeline(Object.assign({
        layout: dynamicPipelineLayout
      }, pipelineDesc));

      const vertexBuffer = device.createBuffer({
        size: 2 * 3 * vec4Size,
        usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.VERTEX
      });

      vertexBuffer.setSubData(0, new Float32Array([
        // position data  /**/ color data
        0, 0.1, 0, 1,     /**/ 1, 0, 0, 1,
        -0.1, -0.1, 0, 1, /**/ 0, 1, 0, 1,
        0.1, -0.1, 0, 1,  /**/ 0, 0, 1, 1,
      ]));

      function configure() {
        const numTriangles = settings.numTriangles;

        const uniformBytes = 5 * Float32Array.BYTES_PER_ELEMENT;
        const alignedUniformBytes = Math.ceil(uniformBytes / 256) * 256;
        const alignedUniformFloats = alignedUniformBytes / Float32Array.BYTES_PER_ELEMENT;

        const uniformBuffer = device.createBuffer({
          size: numTriangles * alignedUniformBytes + Float32Array.BYTES_PER_ELEMENT,
          usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.UNIFORM
        });

        const uniformBufferData = new Float32Array(numTriangles * alignedUniformFloats);

        const bindGroups = new Array(numTriangles);
        for (let i = 0; i < numTriangles; ++i) {
          uniformBufferData[alignedUniformFloats * i + 0] = Math.random() * 0.2 + 0.2;        // scale
          uniformBufferData[alignedUniformFloats * i + 1] = 0.9 * 2 * (Math.random() - 0.5);  // offsetX
          uniformBufferData[alignedUniformFloats * i + 2] = 0.9 * 2 * (Math.random() - 0.5);  // offsetY
          uniformBufferData[alignedUniformFloats * i + 3] = Math.random() * 1.5 + 0.5;       // scalar
          uniformBufferData[alignedUniformFloats * i + 4] = Math.random() * 10;               // scalarOffset

          bindGroups[i] = device.createBindGroup({
            layout: bindGroupLayout,
            bindings: [{
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                offset: i * alignedUniformBytes,
                size: 6 * Float32Array.BYTES_PER_ELEMENT,
              }
            }]
          });
        }

        const dynamicBindGroup = device.createBindGroup({
          layout: dynamicBindGroupLayout,
          bindings: [{
            binding: 0,
            resource: {
              buffer: uniformBuffer,
              offset: 0,
              size: uniformBufferData.byteLength,
            },
          }],
        });

        const timeOffset = numTriangles * alignedUniformBytes;
        const timeBindGroup = device.createBindGroup({
          layout: timeBindGroupLayout,
          bindings: [{
            binding: 0,
            resource: {
              buffer: uniformBuffer,
              offset: timeOffset,
              size: Float32Array.BYTES_PER_ELEMENT,
            }
          }]
        });

        // Chrome currently crashes with |setSubData| too large.
        const maxSetSubDataLength = 14 * 1024 * 1024 / Float32Array.BYTES_PER_ELEMENT;
        for (let offset = 0; offset < uniformBufferData.length; offset += maxSetSubDataLength) {
          uniformBuffer.setSubData(offset, new Float32Array(
            uniformBufferData.buffer,
            offset * Float32Array.BYTES_PER_ELEMENT,
            Math.min(uniformBufferData.length - offset, maxSetSubDataLength))
          );
        }

        function createCommandBuffer(textureView) {
          const commandEncoder = device.createCommandEncoder({});

          const renderPassDescriptor = {
            colorAttachments: [{
              loadOp: "clear",
              storeOp: "store",
              clearColor: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
              attachment: textureView,
            }],
          };

          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          if (settings.dynamicOffsets) {
            passEncoder.setPipeline(dynamicPipeline);
          } else {
            passEncoder.setPipeline(pipeline);
          }
          passEncoder.setVertexBuffers(0, [vertexBuffer], [0]);
          passEncoder.setBindGroup(0, timeBindGroup);
          for (let i = 0; i < numTriangles; ++i) {
            if (settings.dynamicOffsets) {
              passEncoder.setBindGroup(1, dynamicBindGroup, [i * alignedUniformBytes]);
            } else {
              passEncoder.setBindGroup(1, bindGroups[i]);
            }
            passEncoder.draw(3, 1, 0, 0);
          }
          passEncoder.endPass();
          return commandEncoder.finish();
        }

        const reusableFrames = [];
        for (let i = 0; i < 2; ++i) {
          const texture = device.createTexture({
            size: { width: canvas.width, height: canvas.height, depth: 1 },
            arrayLayerCount: 1,
            mipLevelCount: 1,
            sampleCount: 1,
            dimension: "2d",
            format: swapChainFormat,
            usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.TRANSFER_SRC,
          });

          reusableFrames.push({
            commandBuffer: createCommandBuffer(texture.createDefaultView()),
            texture,
          });
        }

        const uniformTime = new Float32Array([0]);

        let i = 0;
        let startTime = undefined;
        return function doDraw(timestamp) {
          if (startTime === undefined) {
            startTime = timestamp;
          }
          uniformTime[0] = (timestamp - startTime) / 1000;
          uniformBuffer.setSubData(timeOffset, uniformTime);

          if (settings.reuseCommandBuffers) {
            const { commandBuffer, texture } = reusableFrames[(i + 1) % reusableFrames.length];
            i++;

            const commandEncoder = device.createCommandEncoder({});
            commandEncoder.copyTextureToTexture(
              {
                texture: texture,
                mipLevel: 0,
                arrayLayer: 0,
                origin: { x: 0, y: 0, z: 0 }
              },
              {
                texture: swapChain.getCurrentTexture(),
                mipLevel: 0,
                arrayLayer: 0,
                origin: { x: 0, y: 0, z: 0 }
              },
              {
                width: canvas.width,
                height: canvas.height,
                depth: 1,
              },
            );

            device.getQueue().submit([
              commandBuffer,
              commandEncoder.finish(),
            ]);
          } else {
            const textureView = swapChain.getCurrentTexture().createDefaultView();
            device.getQueue().submit([createCommandBuffer(textureView)]);
          }
        }
      }

      let doDraw = configure();
      const updateSettings = () => { doDraw = configure(); }

      const gui = new dat.GUI();
      gui.add(settings, 'numTriangles', 0, 200000).step(1).onFinishChange(updateSettings);
      gui.add(settings, 'reuseCommandBuffers');
      gui.add(settings, 'dynamicOffsets');

      let previousFrameTimestamp = undefined;

      let jsTimeAvg = undefined;
      let frameTimeAvg = undefined;

      const perfDisplay = document.getElementById('display');
      let updateDisplay = true;

      let i = 0;
      function frame(timestamp) {
        let frameTime = 0;
        if (previousFrameTimestamp !== undefined) {
          frameTime = timestamp - previousFrameTimestamp;
        }
        previousFrameTimestamp = timestamp;

        const start = performance.now();
        doDraw(timestamp);
        const jsTime = performance.now() - start;

        if (frameTimeAvg === undefined) {
          frameTimeAvg = frameTime;
        }

        if (jsTimeAvg === undefined) {
          jsTimeAvg = jsTime;
        }

        const w = 0.2;
        frameTimeAvg = (1 - w) * frameTimeAvg + w * frameTime;
        jsTimeAvg = (1 - w) * jsTimeAvg + w * jsTime;

        if (updateDisplay) {
          perfDisplay.innerHTML = `Avg Javascript: ${jsTimeAvg.toFixed(2)} ms\nAvg Frame: ${frameTimeAvg.toFixed(2)} ms`;
          updateDisplay = false;
        }

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      setInterval(() => {
        updateDisplay = true;
      }, 100);
    }

    init();
  </script>

  <script data-href="https://github.com/austinEng/webgpu-samples/blob/master/animometer.html"
    src="https://unpkg.com/github-corners/dist/embed.min.js"></script>
</body>

</html>
